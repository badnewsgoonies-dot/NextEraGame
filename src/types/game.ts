/*
 * NextEra MVP Type System
 * 
 * Core data contracts for the NextRealDeal MVP.
 * Based on architecture decisions (Oct 20, 2025):
 * - Role = Archetype (Decision #3)
 * - No threat scores (Decision #2)
 * - Static counter tags (Decision #4)
 * - Permadeath defeat flow (Decision #5)
 */

/**
 * NextEraGame - Type System
 * 
 * This file contains all type definitions for the game.
 * 
 * ============================================
 * IMPLEMENTATION STATUS
 * ============================================
 * 
 * âœ… FULLY IMPLEMENTED:
 * - Core game types (Unit, Opponent, Battle, Reward, etc.)
 * - Save/load system types (SaveEnvelope, SaveSliceChoice, etc.)
 * - State machine types (GameState, transitions)
 * - All current game systems have full type coverage
 * 
 * ðŸ“‹ PLANNED (Type scaffolding in place, NOT YET IMPLEMENTED):
 * - Equipment System (Equipment interface)
 * - Inventory Management (InventoryData interface)
 * - Leveling System (LevelingData interface)
 * - Power Booster System (PowerBooster interface)
 * 
 * ============================================
 * WHEN IMPLEMENTING FUTURE FEATURES
 * ============================================
 * 
 * Follow this process:
 * 1. Remove "TODO" comments from relevant type
 * 2. Create corresponding System class (e.g., EquipmentSystem.ts)
 * 3. Create UI screens/components
 * 4. Write comprehensive tests (unit + integration)
 * 5. Update save/load logic with proper defaults
 * 6. Update GameController to orchestrate new system
 * 7. Add to state machine if new screens needed
 * 
 * All future feature fields in SaveEnvelope are OPTIONAL
 * to maintain backward compatibility with existing saves.
 */

import type { Result } from '../utils/Result.js';

// ============================================
// Core Game Types
// ============================================

/**
 * Unit role (also serves as archetype per Decision #3)
 */
export type Role = 'Tank' | 'DPS' | 'Support' | 'Specialist';

/**
 * Unit tags for type advantages and theming
 */
export type Tag = 'Undead' | 'Mech' | 'Beast' | 'Holy' | 'Arcane' | 'Nature';

/**
 * Opponent difficulty levels
 * - Standard: Easiest, at least one per choice set
 * - Normal: Moderate difficulty
 * - Hard: Challenging, at most one per choice set
 */
export type Difficulty = 'Standard' | 'Normal' | 'Hard';

// ============================================
// Unit System
// ============================================

/**
 * Basic combat unit (minimal interface for battles)
 */
export interface Unit {
  readonly id: string;
  readonly name: string;
  readonly hp: number;
  readonly maxHp: number;
  readonly atk: number;
  readonly def: number;
  readonly speed: number;
}

/**
 * Enemy unit template (catalog definition)
 */
export interface EnemyUnitTemplate {
  readonly id: string;
  readonly name: string;
  readonly role: Role;
  readonly tags: readonly Tag[];
  readonly baseStats: {
    readonly hp: number;
    readonly atk: number;
    readonly def: number;
    readonly speed: number;
  };
  readonly portraitUrl?: string;
  readonly spriteUrl?: string;
  readonly description?: string;
}

/**
 * Player unit (extends Unit with team metadata)
 */
export interface PlayerUnit extends Unit {
  readonly role: Role;
  readonly tags: readonly Tag[];
  readonly level: number;
  readonly experience: number;
  readonly portraitUrl?: string;
  readonly spriteUrl?: string;
}

/**
 * Battle unit (mutable combat state)
 * Used during battle execution - allows HP to change
 */
export interface BattleUnit {
  readonly id: string;
  readonly name: string;
  readonly role: Role;
  readonly tags: readonly Tag[];
  currentHp: number; // MUTABLE during battle
  readonly maxHp: number;
  readonly atk: number;
  readonly def: number;
  readonly speed: number;
  readonly isPlayer: boolean;
  readonly originalIndex: number; // For deterministic tie-breaking
}

// ============================================
// Opponent System (ChoiceSystem)
// ============================================

/**
 * Opponent specification (catalog entry)
 * Defines a complete opponent encounter
 */
export interface OpponentSpec {
  readonly id: string;
  readonly name: string;
  readonly difficulty: Difficulty;
  readonly units: readonly EnemyUnitTemplate[];
  readonly primaryTag: Tag; // For diversity checks
  readonly counterTags: readonly Tag[]; // Decision #4: Static, manually curated
  readonly specialRule?: string; // Optional special battle mechanic
  readonly rewardHint: string; // What player might get (e.g., "Dark Artifacts")
}

/**
 * Opponent preview card (shown in opponent select screen)
 * Generated by ChoiceSystem from OpponentSpec
 */
export interface OpponentPreview {
  readonly spec: OpponentSpec;
  readonly threatScore?: number; // Decision #2: Omitted from MVP (undefined)
  readonly counterTags: readonly Tag[]; // Copied from spec for convenience
  readonly unitSummaries: readonly { name: string; role: Role }[] | null; // null = "???" mystery
}

// ============================================
// Save System
// ============================================

/**
 * Choice system save slice
 * Stores seed and battle index for deterministic opponent generation
 */
export interface SaveSliceChoice {
  readonly nextChoiceSeed: string; // Seed for next opponent choice generation
  readonly battleIndex: number; // How many battles completed (used for RNG fork)
  readonly lastChoices?: readonly OpponentPreview[]; // For UI state restoration
}

/**
 * Progression counters (persistent across runs)
 */
export interface ProgressionCounters {
  readonly runsAttempted: number; // Total runs started
  readonly runsCompleted: number; // Runs that reached final boss/completion
  readonly battlesWon: number; // Total battles won (all time)
  readonly battlesLost: number; // Total battles lost (all time)
  readonly unitsRecruited: number; // Total units recruited (all time)
}

/**
 * Complete save state envelope
 */
export interface SaveEnvelope {
  readonly version: 'v1'; // Versioning for future migrations
  readonly timestamp: string; // ISO 8601 timestamp
  readonly playerTeam: readonly PlayerUnit[]; // Current team (max 4)
  readonly inventory: readonly Item[]; // Player's items
  readonly progression: ProgressionCounters; // Persistent stats
  readonly choice: SaveSliceChoice; // Next opponent choice state
  readonly runSeed: number; // Root seed for this run
  
  // ============================================
  // FUTURE FEATURES (Optional - Backward Compatible)
  // These fields are optional to maintain save compatibility.
  // When implementing, provide defaults for missing values.
  // ============================================
  
  /**
   * Equipment system data (Planned)
   * Default: {} if undefined
   */
  readonly equippedItems?: Record<string, Equipment[]>; // unitId -> equipped items
  
  /**
   * Full inventory data (Planned)
   * Default: { items: [], equipment: [], maxItemSlots: 50, maxEquipmentSlots: 50 }
   */
  readonly inventoryData?: InventoryData;
  
  /**
   * Per-unit leveling data (Planned)
   * Default: {} if undefined
   */
  readonly levelingData?: Record<string, LevelingData>; // unitId -> leveling data
  
  /**
   * Active power boosters (Planned)
   * Default: [] if undefined
   */
  readonly activeBoosters?: readonly PowerBooster[];
}

// ============================================
// Economy & Rewards
// ============================================

/**
 * Item type
 */
export type ItemType = 'weapon' | 'armor' | 'accessory' | 'consumable';

/**
 * Item (equipment or consumable)
 */
export interface Item {
  readonly id: string;
  readonly name: string;
  readonly type: ItemType;
  readonly description?: string;
  readonly stats?: {
    readonly atkBonus?: number;
    readonly defBonus?: number;
    readonly speedBonus?: number;
    readonly hpRestore?: number;
  };
  readonly rarity?: 'common' | 'rare' | 'epic';
}

/**
 * Loot drop configuration
 */
export interface LootDrop {
  readonly itemId: string;
  readonly probability: number; // 0-1
}

/**
 * Battle rewards
 */
export interface BattleReward {
  readonly items: readonly Item[];
  readonly defeatedEnemies: readonly EnemyUnitTemplate[]; // Available for recruitment
  readonly experience: number;
}

// ============================================
// Battle System
// ============================================

/**
 * Battle state
 */
export interface BattleState {
  readonly units: readonly Unit[]; // All units (player + enemies)
  readonly turnOrder: readonly string[]; // Unit IDs in initiative order
  readonly currentTurn: number;
  readonly isActive: boolean;
}

/**
 * Combat action in the log
 */
export interface CombatAction {
  readonly type: 'attack' | 'defend' | 'defeat';
  readonly actorId: string;
  readonly targetId?: string;
  readonly damage?: number;
  readonly critical?: boolean;
  readonly dodged?: boolean;
  readonly seq: number; // Deterministic sequence number (NOT timestamp)
}

/**
 * Battle result (after battle ends)
 */
export interface BattleResult {
  readonly winner: 'player' | 'enemy' | 'draw'; // Draw added for simultaneous defeat or stalemate
  readonly actions: readonly CombatAction[];
  readonly unitsDefeated: readonly string[]; // Unit IDs
  readonly turnsTaken: number;
}

// ============================================
// State Machine
// ============================================

/**
 * Game states for MVP loop
 * Transitions: menu â†’ starter_select â†’ opponent_select â†’ team_prep â†’ battle â†’ rewards â†’ recruit â†’ opponent_select (loop)
 * Defeat: battle â†’ defeat â†’ menu
 */
export type GameState =
  | 'menu'
  | 'starter_select'
  | 'opponent_select'
  | 'team_prep'
  | 'battle'
  | 'rewards'
  | 'recruit'
  | 'defeat' // Decision #5: Permadeath flow
  // ============================================
  // FUTURE STATES (Not yet implemented)
  // ============================================
  | 'inventory'    // TODO: Inventory management screen
  | 'equipment'    // TODO: Equipment management screen  
  | 'level_up';    // TODO: Level-up screen with stat allocation

/**
 * Valid state transitions
 */
export const STATE_TRANSITIONS: Record<GameState, readonly GameState[]> = {
  menu: ['starter_select'],
  starter_select: ['opponent_select'],
  opponent_select: ['team_prep'],
  team_prep: ['battle'],
  battle: ['rewards', 'defeat', 'menu'], // Can win, lose, or draw (draw = instant restart)
  rewards: ['recruit'],
  recruit: ['opponent_select'], // Loop back for next battle
  defeat: ['menu'], // Decision #5: Instant restart
  
  // ============================================
  // FUTURE TRANSITIONS (Not yet wired)
  // ============================================
  inventory: ['menu', 'team_prep'], // TODO: Access from menu or before battle
  equipment: ['inventory', 'menu'], // TODO: Access from inventory or menu
  level_up: ['rewards', 'recruit'], // TODO: Trigger after rewards if level gained
} as const;

// ============================================
// Event System (Telemetry)
// ============================================

/**
 * Game event types for logging and telemetry
 */
export type GameEventType =
  | 'choice:generated'
  | 'choice:selected'
  | 'choice:degraded'
  | 'battle:started'
  | 'battle:ended'
  | 'battle:defeat'
  | 'unit:recruited'
  | 'run:started'
  | 'run:completed';

/**
 * Game event with metadata
 */
export interface GameEvent<T = unknown> {
  readonly type: GameEventType;
  readonly timestamp: number; // Unix timestamp in ms
  readonly data: T;
}

/**
 * Choice generation event metadata
 */
export interface ChoiceGeneratedEvent {
  readonly battleIndex: number;
  readonly previews: readonly { id: string; difficulty: Difficulty; primaryTag: Tag }[];
  readonly seed: number;
  readonly attempts: number; // How many re-rolls before success
  readonly degraded: boolean; // Whether constraints were relaxed
}

/**
 * Choice selection event metadata
 */
export interface ChoiceSelectedEvent {
  readonly battleIndex: number;
  readonly selectedId: string;
  readonly difficulty: Difficulty;
  readonly primaryTag: Tag;
}

/**
 * Battle event metadata
 */
export interface BattleStartedEvent {
  readonly battleIndex: number;
  readonly opponentId: string;
  readonly playerTeam: readonly { id: string; name: string; role: Role }[];
  readonly enemyTeam: readonly { id: string; name: string; role: Role }[];
}

// ============================================
// Utility Types
// ============================================

/**
 * Basic position
 */
export interface Position {
  readonly x: number;
  readonly y: number;
}

/**
 * Feature flags
 */
export interface FeatureFlags {
  readonly opponentChoice: boolean; // Enable opponent selection (off in prod until QA)
  readonly counterTags: boolean; // Show counter tags on opponent cards
  readonly devOverlay: boolean; // F1 debug overlay
}

/**
 * Default feature flags
 */
export const DEFAULT_FLAGS: FeatureFlags = {
  opponentChoice: process.env.NODE_ENV === 'development',
  counterTags: process.env.NODE_ENV === 'development',
  devOverlay: process.env.NODE_ENV === 'development',
} as const;

// ============================================
// System Interfaces
// ============================================

/**
 * Common system lifecycle
 */
export interface ISystem {
  readonly name: string;
  initialize(): Promise<Result<void, Error>>;
  update?(deltaTime: number): Promise<Result<void, Error>>;
  destroy(): Promise<void>;
}

/**
 * Serializable system (for save/load)
 */
export interface ISerializable {
  serialize(): string;
  deserialize(json: string): Result<void, Error>;
}

/**
 * Save store interface (storage abstraction)
 */
export interface ISaveStore {
  write(slot: string, payload: string): Promise<void>;
  read(slot: string): Promise<string>;
  delete(slot: string): Promise<void>;
  list(): Promise<Array<{ slot: string; modified: string; size: number }>>;
}

// ============================================
// FUTURE FEATURES (Type Scaffolding Only)
// ============================================

/**
 * Equipment System (Planned - Not Yet Implemented)
 * 
 * TODO: Implement when ready:
 * - Create EquipmentSystem class
 * - Create Equipment screen/UI
 * - Add equip/unequip logic
 * - Write comprehensive tests
 */
export interface Equipment {
  readonly id: string;
  readonly name: string;
  readonly description: string;
  readonly slot: 'weapon' | 'armor' | 'accessory';
  readonly stats: {
    readonly hp?: number;
    readonly atk?: number;
    readonly def?: number;
    readonly speed?: number;
  };
  readonly rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';
  readonly levelRequirement?: number;
  readonly spriteUrl?: string;
}

/**
 * Inventory System (Planned - Not Yet Implemented)
 * 
 * TODO: Implement when ready:
 * - Create InventorySystem class
 * - Create Inventory screen/UI
 * - Add item management logic
 * - Write comprehensive tests
 */
export interface InventoryData {
  readonly items: readonly Item[];
  readonly equipment: readonly Equipment[];
  readonly maxItemSlots: number;
  readonly maxEquipmentSlots: number;
}

/**
 * Leveling System (Planned - Not Yet Implemented)
 * 
 * TODO: Implement when ready:
 * - Create LevelingSystem class
 * - Create Level-up screen/UI
 * - Add XP calculation and stat growth
 * - Write comprehensive tests
 */
export interface LevelingData {
  readonly unitId: string;
  readonly currentXP: number;
  readonly level: number;
  readonly xpToNextLevel: number;
  readonly statPoints?: number; // For manual allocation (if implemented)
  readonly statGrowth?: {
    readonly hp: number;
    readonly atk: number;
    readonly def: number;
    readonly speed: number;
  };
}

/**
 * Power Booster System (Planned - Not Yet Implemented)
 * 
 * TODO: Implement when ready:
 * - Create PowerBoosterSystem class
 * - Add buff/debuff application logic
 * - Add visual indicators in battle
 * - Write comprehensive tests
 */
export interface PowerBooster {
  readonly id: string;
  readonly name: string;
  readonly description: string;
  readonly type: 'buff' | 'debuff';
  readonly statModifier: {
    readonly hp?: number;
    readonly atk?: number;
    readonly def?: number;
    readonly speed?: number;
  };
  readonly duration: number; // Number of battles or turns
  readonly stackable: boolean;
  readonly iconUrl?: string;
}
