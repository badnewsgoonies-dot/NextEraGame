/*
 * NextEra MVP Type System
 * 
 * Core data contracts for the NextRealDeal MVP.
 * Based on architecture decisions (Oct 20, 2025):
 * - Role = Archetype (Decision #3)
 * - No threat scores (Decision #2)
 * - Static counter tags (Decision #4)
 * - Permadeath defeat flow (Decision #5)
 */

import type { Result } from '../utils/Result.js';

// ============================================
// Core Game Types
// ============================================

/**
 * Unit role (also serves as archetype per Decision #3)
 */
export type Role = 'Tank' | 'DPS' | 'Support' | 'Specialist';

/**
 * Unit tags for type advantages and theming
 */
export type Tag = 'Undead' | 'Mech' | 'Beast' | 'Holy' | 'Arcane' | 'Nature';

/**
 * Opponent difficulty levels
 * - Standard: Easiest, at least one per choice set
 * - Normal: Moderate difficulty
 * - Hard: Challenging, at most one per choice set
 */
export type Difficulty = 'Standard' | 'Normal' | 'Hard';

// ============================================
// Unit System
// ============================================

/**
 * Basic combat unit (minimal interface for battles)
 */
export interface Unit {
  readonly id: string;
  readonly name: string;
  readonly hp: number;
  readonly maxHp: number;
  readonly atk: number;
  readonly def: number;
  readonly speed: number;
}

/**
 * Enemy unit template (catalog definition)
 */
export interface EnemyUnitTemplate {
  readonly id: string;
  readonly name: string;
  readonly role: Role;
  readonly tags: readonly Tag[];
  readonly baseStats: {
    readonly hp: number;
    readonly atk: number;
    readonly def: number;
    readonly speed: number;
  };
  readonly portraitUrl?: string;
  readonly spriteUrl?: string;
  readonly description?: string;
}

/**
 * Player unit (extends Unit with team metadata)
 */
export interface PlayerUnit extends Unit {
  readonly role: Role;
  readonly tags: readonly Tag[];
  readonly level: number;
  readonly experience: number;
  readonly portraitUrl?: string;
  readonly spriteUrl?: string;
}

/**
 * Battle unit (mutable combat state)
 * Used during battle execution - allows HP to change
 */
export interface BattleUnit {
  readonly id: string;
  readonly name: string;
  readonly role: Role;
  readonly tags: readonly Tag[];
  currentHp: number; // MUTABLE during battle
  readonly maxHp: number;
  readonly atk: number;
  readonly def: number;
  readonly speed: number;
  readonly isPlayer: boolean;
  readonly originalIndex: number; // For deterministic tie-breaking
}

// ============================================
// Opponent System (ChoiceSystem)
// ============================================

/**
 * Opponent specification (catalog entry)
 * Defines a complete opponent encounter
 */
export interface OpponentSpec {
  readonly id: string;
  readonly name: string;
  readonly difficulty: Difficulty;
  readonly units: readonly EnemyUnitTemplate[];
  readonly primaryTag: Tag; // For diversity checks
  readonly counterTags: readonly Tag[]; // Decision #4: Static, manually curated
  readonly specialRule?: string; // Optional special battle mechanic
  readonly rewardHint: string; // What player might get (e.g., "Dark Artifacts")
}

/**
 * Opponent preview card (shown in opponent select screen)
 * Generated by ChoiceSystem from OpponentSpec
 */
export interface OpponentPreview {
  readonly spec: OpponentSpec;
  readonly threatScore?: number; // Decision #2: Omitted from MVP (undefined)
  readonly counterTags: readonly Tag[]; // Copied from spec for convenience
  readonly unitSummaries: readonly { name: string; role: Role }[] | null; // null = "???" mystery
}

// ============================================
// Save System
// ============================================

/**
 * Choice system save slice
 * Stores seed and battle index for deterministic opponent generation
 */
export interface SaveSliceChoice {
  readonly nextChoiceSeed: string; // Seed for next opponent choice generation
  readonly battleIndex: number; // How many battles completed (used for RNG fork)
  readonly lastChoices?: readonly OpponentPreview[]; // For UI state restoration
}

/**
 * Progression counters (persistent across runs)
 */
export interface ProgressionCounters {
  readonly runsAttempted: number; // Total runs started
  readonly runsCompleted: number; // Runs that reached final boss/completion
  readonly battlesWon: number; // Total battles won (all time)
  readonly battlesLost: number; // Total battles lost (all time)
  readonly unitsRecruited: number; // Total units recruited (all time)
}

/**
 * Complete save state envelope
 */
export interface SaveEnvelope {
  readonly version: 'v1'; // Versioning for future migrations
  readonly timestamp: string; // ISO 8601 timestamp
  readonly playerTeam: readonly PlayerUnit[]; // Current team (max 4)
  readonly inventory: readonly Item[]; // Player's items
  readonly progression: ProgressionCounters; // Persistent stats
  readonly choice: SaveSliceChoice; // Next opponent choice state
  readonly runSeed: number; // Root seed for this run
}

// ============================================
// Economy & Rewards
// ============================================

/**
 * Item type
 */
export type ItemType = 'weapon' | 'armor' | 'accessory' | 'consumable';

/**
 * Item (equipment or consumable)
 */
export interface Item {
  readonly id: string;
  readonly name: string;
  readonly type: ItemType;
  readonly description?: string;
  readonly stats?: {
    readonly atkBonus?: number;
    readonly defBonus?: number;
    readonly speedBonus?: number;
    readonly hpRestore?: number;
  };
  readonly rarity?: 'common' | 'rare' | 'epic';
}

/**
 * Loot drop configuration
 */
export interface LootDrop {
  readonly itemId: string;
  readonly probability: number; // 0-1
}

/**
 * Battle rewards
 */
export interface BattleReward {
  readonly items: readonly Item[];
  readonly defeatedEnemies: readonly EnemyUnitTemplate[]; // Available for recruitment
  readonly experience: number;
}

// ============================================
// Battle System
// ============================================

/**
 * Battle state
 */
export interface BattleState {
  readonly units: readonly Unit[]; // All units (player + enemies)
  readonly turnOrder: readonly string[]; // Unit IDs in initiative order
  readonly currentTurn: number;
  readonly isActive: boolean;
}

/**
 * Combat action in the log
 */
export interface CombatAction {
  readonly type: 'attack' | 'defend' | 'defeat';
  readonly actorId: string;
  readonly targetId?: string;
  readonly damage?: number;
  readonly critical?: boolean;
  readonly dodged?: boolean;
  readonly seq: number; // Deterministic sequence number (NOT timestamp)
}

/**
 * Battle result (after battle ends)
 */
export interface BattleResult {
  readonly winner: 'player' | 'enemy' | 'draw'; // Draw added for simultaneous defeat or stalemate
  readonly actions: readonly CombatAction[];
  readonly unitsDefeated: readonly string[]; // Unit IDs
  readonly turnsTaken: number;
}

// ============================================
// State Machine
// ============================================

/**
 * Game states for MVP loop
 * Transitions: menu → starter_select → opponent_select → team_prep → battle → rewards → recruit → opponent_select (loop)
 * Defeat: battle → defeat → menu
 */
export type GameState =
  | 'menu'
  | 'starter_select'
  | 'opponent_select'
  | 'team_prep'
  | 'battle'
  | 'rewards'
  | 'recruit'
  | 'defeat'; // Decision #5: Permadeath flow

/**
 * Valid state transitions
 */
export const STATE_TRANSITIONS: Record<GameState, readonly GameState[]> = {
  menu: ['starter_select'],
  starter_select: ['opponent_select'],
  opponent_select: ['team_prep'],
  team_prep: ['battle'],
  battle: ['rewards', 'defeat', 'menu'], // Can win, lose, or draw (draw = instant restart)
  rewards: ['recruit'],
  recruit: ['opponent_select'], // Loop back for next battle
  defeat: ['menu'], // Decision #5: Instant restart
} as const;

// ============================================
// Event System (Telemetry)
// ============================================

/**
 * Game event types for logging and telemetry
 */
export type GameEventType =
  | 'choice:generated'
  | 'choice:selected'
  | 'choice:degraded'
  | 'battle:started'
  | 'battle:ended'
  | 'battle:defeat'
  | 'unit:recruited'
  | 'run:started'
  | 'run:completed';

/**
 * Game event with metadata
 */
export interface GameEvent<T = unknown> {
  readonly type: GameEventType;
  readonly timestamp: number; // Unix timestamp in ms
  readonly data: T;
}

/**
 * Choice generation event metadata
 */
export interface ChoiceGeneratedEvent {
  readonly battleIndex: number;
  readonly previews: readonly { id: string; difficulty: Difficulty; primaryTag: Tag }[];
  readonly seed: number;
  readonly attempts: number; // How many re-rolls before success
  readonly degraded: boolean; // Whether constraints were relaxed
}

/**
 * Choice selection event metadata
 */
export interface ChoiceSelectedEvent {
  readonly battleIndex: number;
  readonly selectedId: string;
  readonly difficulty: Difficulty;
  readonly primaryTag: Tag;
}

/**
 * Battle event metadata
 */
export interface BattleStartedEvent {
  readonly battleIndex: number;
  readonly opponentId: string;
  readonly playerTeam: readonly { id: string; name: string; role: Role }[];
  readonly enemyTeam: readonly { id: string; name: string; role: Role }[];
}

// ============================================
// Utility Types
// ============================================

/**
 * Basic position
 */
export interface Position {
  readonly x: number;
  readonly y: number;
}

/**
 * Feature flags
 */
export interface FeatureFlags {
  readonly opponentChoice: boolean; // Enable opponent selection (off in prod until QA)
  readonly counterTags: boolean; // Show counter tags on opponent cards
  readonly devOverlay: boolean; // F1 debug overlay
}

/**
 * Default feature flags
 */
export const DEFAULT_FLAGS: FeatureFlags = {
  opponentChoice: process.env.NODE_ENV === 'development',
  counterTags: process.env.NODE_ENV === 'development',
  devOverlay: process.env.NODE_ENV === 'development',
} as const;

// ============================================
// System Interfaces
// ============================================

/**
 * Common system lifecycle
 */
export interface ISystem {
  readonly name: string;
  initialize(): Promise<Result<void, Error>>;
  update?(deltaTime: number): Promise<Result<void, Error>>;
  destroy(): Promise<void>;
}

/**
 * Serializable system (for save/load)
 */
export interface ISerializable {
  serialize(): string;
  deserialize(json: string): Result<void, Error>;
}

/**
 * Save store interface (storage abstraction)
 */
export interface ISaveStore {
  write(slot: string, payload: string): Promise<void>;
  read(slot: string): Promise<string>;
  delete(slot: string): Promise<void>;
  list(): Promise<Array<{ slot: string; modified: string; size: number }>>;
}

